{
    "collab_server" : "",
    "contents" : "#load data in project\n#data <- load(\"/Users/dsalimian/Documents/School/Master/Multivariate Statistics/Week1/supermarket1996.RData\")\n\n# a: program ridge regression as an R function\n\nridgeRegression <- function(X, y, lambda, standardize = TRUE, intercept = TRUE){\n  # NOTE: maybe first test for heteroscedasticity and use dependent on the results either the normal or hetero ridge approach\n  \n  # if we want to standardize our input, then do so here\n  if(standardize){\n    # standardize the columns to z-score\n    X_mean <- apply(X, 2, mean) #note this is a vector containing all column means of matrix X\n    X_stdev <- apply(X, 2, sd) # note this is a vector containing all column standard deviations of matrix X\n    X_stnd <- scale(X,X_mean,X_stdev) # this contains now the z-scores for each column  \n  }\n  \n  # if we do not want any intercept..\n  if(!intercept){\n    # make sure that our (in)dependent variable sums to 0. Hence remove the mean from each observation\n    y_mean <- mean(y)\n    y_stnd <- y-y_mean\n    \n    # only de-mean X when it isn't standardized yet\n    if(!standardize){\n      X_mean <- apply(X, 2, mean) #note this is a vector containing all column means of matrix X\n      X_stnd <- scale(X,X_mean, FALSE)\n    }\n  }else{\n    y_stnd <- y # when we do not de-mean, and thus leave the intercept, we need to rename our dependent var for the rest of the code to work\n  }\n  \n  if(!standardize && intercept){\n    X_stnd <- as.matrix(X) # when we do not standardize, and leave the intercept, we need to rename our input var for the rest of the code to work\n  }\n  \n  # since lambda is given, we can proceed and calculate the beta_ridged now\n  b_ridged <- solve(t(X_stnd) %*% X_stnd + lambda * diag(dim(X_stnd)[2])) %*% t(X_stnd) %*% y\n  \n  # using the esitmates paramters, we can calculate our y_hat values\n  y_hat <- X_stnd %*% b_ridged\n  \n  # now calculate the standard deviation of the estimated parameters b_ridged\n  estimation_error <- y_stnd-y_hat\n  error_variance <- (t(estimation_error)%*%estimation_error)/(dim(X_stnd)[1]-dim(X_stnd)[2])\n  error_variance <- as.numeric(error_variance)\n  \n  b_ridged_var <- error_variance * solve(t(X_stnd) %*% X_stnd + lambda * diag(dim(X_stnd)[2])) %*% t(X_stnd) %*%\n    X_stnd %*% solve(t(X_stnd) %*% X_stnd + lambda * diag(dim(X_stnd)[2]))\n  \n  # calculate the degrees of freedom\n  hat_ridge <- X_stnd %*% solve(t(X_stnd) %*% X_stnd + lambda * diag(dim(X_stnd)[2])) %*% t(X_stnd)\n  df_ridge <- sum(diag(hat_ridge)) # this is taking the trace of the hat_ridge variable\n  \n  # calculate the AIC value\n  AIC <- dim(X_stnd)[2] * log(t(estimation_error)%*%estimation_error) + 2 * df_ridge\n  AIC <- as.numeric(AIC)\n  \n  # calculate the AIC value\n  BIC <- dim(X_stnd)[2] * log(t(estimation_error)%*%estimation_error) + 2 * df_ridge * log(dim(X_stnd)[2])\n  BIC <- as.numeric(BIC)\n  \n  # calculate the correlation coefficient of y and y_hat\n  R = cov(y,y_hat)/(sd(y) * sd(y_hat))\n  R = as.numeric(R)\n  R_sq = R^2\n  \n  result = list(b_ridged=b_ridged, b_ridged_var=b_ridged_var, estimation_error_sum=sum(estimation_error), AIC=AIC, BIC=BIC, R_sq=R_sq, df_ridge=df_ridge)\n  return(result)\n  \n}\n\nX <- supermarket1996[,6:50]\ny <- supermarket1996$GROCCOUP_sum\nlambda = 1\nmodel1 = ridgeRegression(X,y,lambda, standardize = FALSE, intercept = TRUE) # answer to a) 1\nmodel2 = ridgeRegression(X,y,lambda, standardize = FALSE, intercept = FALSE) # answer to a) 2\nmodel3 = ridgeRegression(X,y,lambda, standardize = TRUE, intercept = FALSE) # answer to c)\n\nprint('b_ridged is as follows:')\nprint(model1$b_ridged)\nprint('variance of b_ridged is as follows:')\nprint(model1$b_ridged_var)\npaste('the sum of the estimation errors is', model1$estimation_error_sum)\npaste('the AIC value is', model1$AIC)\npaste('the BIC value is', model1$BIC)\npaste('R^2 value is ', model1$R_sq)\npaste('the effective degrees of freedom is ', model1$df_ridge)\n\n# now get the results using a package that is available for R; glmnet\n\n# install.packages('glmnet') # helps installing the package if neccesary\nlibrary('glmnet')\nridge_glmnet1 = glmnet(as.matrix(X),y, standardize=FALSE, intercept=TRUE) # we can compare this with model1\nridge_glmnet1 \n# note that at lambda = 3064 we have DF = 2. This can be tested with our own function, and we get an DF=1.99. This seems correct\n# note that at lambda = 893200 we have DF = 1. This can be tested with our own function, and we get an DF=1.109. This seems correct\n\nridge_glmnet2 = glmnet(as.matrix(X),y, standardize=FALSE, intercept=FALSE) # we can compare this with model2\nridge_glmnet2\n# note that we only get 5 results, and the lambda is exceptionally high. When choosing lambda = 2.476e+09 for our own function we get\n# a DF=0.139. This differs from the DF=1 given by the package..\n\nridge_glmnet3 = glmnet(as.matrix(X),y, standardize=TRUE, intercept=FALSE, lambda=2500, alpha = 0) # we can compare this with model3\nridge_glmnet3\nlambda = 2500\nmodel3 = ridgeRegression(X,y,lambda, standardize = TRUE, intercept = FALSE)\nmodel3$df_ridge\n\nridge_lm3 <- lm.ridge(y~.-1, cbind(y,X), lambda = lambda)\nridge_lm3\n\n#k-fold\n\nloo <- function(X, y, lmin, lmax, lnum, fun, ...){\n    \n    return <- matrix(c(0,0),lnum,2)\n    for(p in 1:lnum){\n        \n        res <- 0\n        lambda <- exp(log(lmin) + (log(lmax)-log(lmin))/(lnum-1)*(p-1))\n        \n        for(i in 1:dim(X)[1]){\n            yi <- y[-i]\n            Xi <- X[-i,]\n            model <- fun(Xi,yi, lambda, ...)\n            dif <- y[i] - t(model[[1]]) %*% t(as.matrix(X[i,]))\n            res <- res + dif^2\n        }\n        return[p,1] <- lambda\n        return[p,2] <- res\n    }\n    return\n}\n\nwyn2 <- loo(X,y, 0.0001, 1000000, 100, ridgeRegression, TRUE, FALSE)\n",
    "created" : 1472730660152.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1740322355",
    "id" : "C1653118",
    "lastKnownWriteTime" : 1472818787,
    "last_content_update" : 1472818787938,
    "path" : "C:/Users/Armin/Downloads/AssignmentWeek1.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}